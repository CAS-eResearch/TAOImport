#!/usr/bin/env python

import argparse, os, sys, pprint
import numpy as np, tao
from tao.find_modules import find_modules

if __name__ == '__main__':

    # Create the base argumentp arser.
    parser = argparse.ArgumentParser(description='Convert semi-analytic data into TAO format')
    parser.add_argument('-s', '--script', default='taoconv.py', help='script defining conversion (default: taoconv.py)')
    parser.add_argument('-o', '--output', default='output', help='output name')
    parser.add_argument('-i', '--info', action='store_true', help='show information about all fields')
    parser.add_argument('-f', '--field', help='show information about a field')

    # Scan for all modules.
    modules = find_modules()
    for mod in modules:
        mod.add_arguments(parser)

    # Try to locate the script. Because we don't want to parse our arguments yet
    # we need to be a little hacky in determining which script to load.
    try:
        idx = sys.argv.index('-s')
    except ValueError:
        try:
            idx = sys.argv.index('--script')
        except ValueError:
            idx = None
    if idx is not None and idx < len(sys.argv) - 1:
        script_fn = sys.argv[idx + 1]
    else:
        script_fn = 'taoconv.py'
    launch_dir = os.getcwd()
    script = os.path.join(launch_dir, script_fn)

    # If the script exists we need to run it before parsing arguments,
    # or even bailing due to it being missing.
    if os.path.exists(script):

        # Run the user script.
        locals_dict = {}
        globals_dict = {'np': np, 'tao': tao, 'parser': parser}
        execfile(script, globals_dict, locals_dict)

    # Now we can parse command line arguments.
    args = parser.parse_args()

    # Now we can abort if the script is missing.
    if not os.path.exists(script):
        print 'Unable to find script: "%s"'%script_fn
        sys.exit(1)

    # Check if the user wants information about a field.
    if args.field:
        for mod in modules:
            if args.field in mod.fields:
                pprint.pprint({args.field: mod.fields[args.field]})
                sys.exit(0)
        print 'Unknown field: ' + args.field
        sys.exit(1)

    # Similarly check for information about all fields.
    if args.info:
        all_fields = {}
        for mod in modules:
            for field, details in mod.fields.iteritems():
                all_fields[field] = details
        pprint.pprint(all_fields)
        sys.exit(0)

    # Confirm we have enough basic information.
    sim = locals_dict.get('simulation', None)
    if sim is None:
        print '\n'.join([
            'No simulation information has been specified in your conversion script. ',
            'Please add a dictionary of simulation information composed of the Hubble ',
            'constant, OmegaM, OmegaL, and the box size.'
        ])
        sys.exit(1)
    if 'hubble' not in sim:
        print '\n'.join([
            'No Hubble value found in simulation data.'
        ])
        sys.exit(1)
    if 'omega_m' not in sim:
        print '\n'.join([
            'No OmegaM value found in simulation data.'
        ])
        sys.exit(1)
    if 'omega_l' not in sim:
        print '\n'.join([
            'No OmegaL value found in simulation data.'
        ])
        sys.exit(1)
    if 'box_size' not in sim:
        print '\n'.join([
            'No box size value found in simulation data.'
        ])
        sys.exit(1)
    redshifts = locals_dict.get('snapshot_redshifts', None)
    if redshifts is None:
        print '\n'.join([
            'No snapshot redshift data found.',
        ])
        sys.exit(1)

    # Cache some information for other parts of the system.
    tao.library['box_size'] = sim['box_size']
    tao.library['redshifts'] = redshifts
    tao.library['n_snapshots'] = len(redshifts)

    # Now run the exporter.
    with tao.Exporter(args.output, modules, locals_dict.get('mapping', None), arguments=args) as exp:
        exp.set_cosmology(sim['hubble'], sim['omega_m'], sim['omega_l'])
        exp.set_box_size(sim['box_size'])
        exp.set_redshifts(redshifts)
        for tree in locals_dict['iterate_trees'](args):
            exp.add_tree(tree)
